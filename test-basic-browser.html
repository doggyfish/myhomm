<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyHoMM Basic Browser Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #ffffff;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #ff6b35;
            padding-bottom: 20px;
        }
        
        .test-header h1 {
            color: #ff6b35;
            font-size: 32px;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff6b35;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .test-section h2 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .test-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .test-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .test-btn:hover {
            background: linear-gradient(45deg, #66BB6A, #4CAF50);
            transform: translateY(-2px);
        }
        
        .test-btn.danger {
            background: linear-gradient(45deg, #f44336, #ef5350);
        }
        
        .test-btn.danger:hover {
            background: linear-gradient(45deg, #ef5350, #f44336);
        }
        
        .test-btn.warning {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
        }
        
        .test-output {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .test-result {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid #2196F3;
            border-radius: 6px;
            padding: 10px;
        }
        
        .test-result.pass {
            background: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
        }
        
        .test-result.fail {
            background: rgba(244, 67, 54, 0.1);
            border-color: #f44336;
        }
        
        .test-result.warning {
            background: rgba(255, 152, 0, 0.1);
            border-color: #ff9800;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-pass { background: #4CAF50; }
        .status-fail { background: #f44336; }
        .status-warning { background: #ff9800; }
        .status-pending { background: #9E9E9E; }
        
        .error-log {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>üè∞ MyHoMM Basic Browser Test Suite</h1>
            <p>Comprehensive testing for game systems and error detection</p>
        </div>

        <!-- System Initialization Tests -->
        <div class="test-section">
            <h2>üîß System Initialization Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="runSystemTests()">Run System Tests</button>
                <button class="test-btn" onclick="testAISettings()">Test AI Settings</button>
                <button class="test-btn" onclick="testMemoryLeaks()">Memory Leak Test</button>
                <button class="test-btn danger" onclick="simulateNullSettings()">Simulate Null Settings Bug</button>
            </div>
            <div class="test-output" id="systemOutput"></div>
            <div class="test-results" id="systemResults"></div>
        </div>

        <!-- Core Game Tests -->
        <div class="test-section">
            <h2>üéÆ Core Game Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testGameCreation()">Test Game Creation</button>
                <button class="test-btn" onclick="testPlayerSystems()">Test Player Systems</button>
                <button class="test-btn" onclick="testCastleSystems()">Test Castle Systems</button>
                <button class="test-btn" onclick="testCombatSystems()">Test Combat Systems</button>
            </div>
            <div class="test-output" id="gameOutput"></div>
            <div class="test-results" id="gameResults"></div>
        </div>

        <!-- AI System Tests -->
        <div class="test-section">
            <h2>ü§ñ AI System Stress Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="stressTestAI()">Stress Test AI</button>
                <button class="test-btn" onclick="testAIEdgeCases()">Test AI Edge Cases</button>
                <button class="test-btn warning" onclick="corruptAISettings()">Corrupt AI Settings</button>
                <button class="test-btn danger" onclick="nullifyAIData()">Nullify AI Data</button>
            </div>
            <div class="test-output" id="aiOutput"></div>
            <div class="test-results" id="aiResults"></div>
        </div>

        <!-- Mobile/Touch System Tests -->
        <div class="test-section">
            <h2>üì± Mobile/Touch System Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testTouchManager()">Test Touch Manager</button>
                <button class="test-btn" onclick="testMobileUI()">Test Mobile UI</button>
                <button class="test-btn" onclick="testPerformanceManager()">Test Performance</button>
                <button class="test-btn" onclick="simulateLowMemory()">Simulate Low Memory</button>
            </div>
            <div class="test-output" id="mobileOutput"></div>
            <div class="test-results" id="mobileResults"></div>
        </div>

        <!-- Error Simulation Tests -->
        <div class="test-section">
            <h2>üí• Error Simulation & Recovery Tests</h2>
            <div class="test-controls">
                <button class="test-btn danger" onclick="simulateRandomErrors()">Random Errors</button>
                <button class="test-btn danger" onclick="simulateMemoryError()">Memory Errors</button>
                <button class="test-btn danger" onclick="simulateNullPointers()">Null Pointer Errors</button>
                <button class="test-btn warning" onclick="testErrorRecovery()">Test Error Recovery</button>
            </div>
            <div class="test-output" id="errorOutput"></div>
            <div class="test-results" id="errorResults"></div>
        </div>

        <!-- Real-time Monitoring -->
        <div class="test-section">
            <h2>üìä Real-time System Monitoring</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="startMonitoring()">Start Monitoring</button>
                <button class="test-btn" onclick="stopMonitoring()">Stop Monitoring</button>
                <button class="test-btn" onclick="generateReport()">Generate Report</button>
                <button class="test-btn" onclick="clearLogs()">Clear All Logs</button>
            </div>
            <div class="test-output" id="monitorOutput"></div>
        </div>
    </div>

    <!-- Load platform detection and system loader -->
    <script src="src/core/PlatformDetector.js"></script>
    <script src="src/core/SystemLoader.js"></script>
    
    <!-- Load core systems for testing -->
    <script src="src/entities/Player.js"></script>
    <script src="src/entities/Castle.js"></script>
    <script src="src/entities/Army.js"></script>
    <script src="src/systems/ProductionSystem.js"></script>
    <script src="src/systems/CombatSystem.js"></script>
    <script src="src/systems/MovementSystem.js"></script>
    <script src="src/systems/AISystem.js"></script>
    <script src="src/ui/InputHandler.js"></script>
    <script src="src/ui/Renderer.js"></script>
    <script src="src/core/Game.js"></script>
    
    <!-- Conditionally load systems based on platform -->
    <script>
        const testPlatformDetector = new PlatformDetector();
        const testSystemLoader = new SystemLoader(testPlatformDetector);
        
        console.log('üß™ Test Suite Platform Detection:');
        console.log('Platform:', testPlatformDetector.platform.type);
        console.log('Mobile mode:', testPlatformDetector.shouldUseMobileMode());
        console.log('Systems to load:', testPlatformDetector.systemsToLoad);
        
        // Load mobile systems only if needed (for testing)
        if (testPlatformDetector.shouldUseMobileMode()) {
            const mobileScripts = [
                'src/mobile/MobileOptimizer.js',
                'src/mobile/TouchManager.js',
                'src/mobile/MobilePerformanceManager.js',
                'src/mobile/MobileUIManager.js',
                'src/mobile/MobileCombatSystem.js',
                'src/mobile/MobileGameManager.js'
            ];
            
            mobileScripts.forEach(src => {
                const script = document.createElement('script');
                script.src = src;
                script.async = false;
                document.head.appendChild(script);
            });
            
            console.log('üì± Mobile systems loaded for testing');
        } else {
            console.log('üñ•Ô∏è Desktop mode - mobile systems skipped');
        }
    </script>

    <script>
        // Test Suite Implementation
        let testGame = null;
        let monitoringInterval = null;
        let testResults = {
            system: [],
            game: [],
            ai: [],
            mobile: [],
            error: []
        };

        // Utility functions
        function log(category, message, type = 'info') {
            const output = document.getElementById(category + 'Output');
            const timestamp = new Date().toLocaleTimeString();
            const typeIcon = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            output.textContent += `[${timestamp}] ${typeIcon} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function addResult(category, name, status, details = '') {
            const results = document.getElementById(category + 'Results');
            const result = document.createElement('div');
            result.className = `test-result ${status}`;
            
            const statusClass = status === 'pass' ? 'status-pass' : status === 'fail' ? 'status-fail' : 'status-warning';
            result.innerHTML = `
                <div><span class="status-indicator ${statusClass}"></span><strong>${name}</strong></div>
                <div style="font-size: 12px; margin-top: 5px; color: #B0BEC5;">${details}</div>
            `;
            
            results.appendChild(result);
            testResults[category].push({ name, status, details, timestamp: Date.now() });
        }

        // System Initialization Tests
        function runSystemTests() {
            log('system', 'Starting system initialization tests...', 'info');
            
            try {
                // Test platform detection system
                testPlatformDetection();
                
                // Test Game class existence
                if (typeof Game !== 'undefined') {
                    addResult('system', 'Game Class', 'pass', 'Game class loaded successfully');
                    log('system', 'Game class: PASSED', 'success');
                } else {
                    addResult('system', 'Game Class', 'fail', 'Game class not found');
                    log('system', 'Game class: FAILED', 'error');
                }
                
                // Test conditional loading system
                testConditionalLoading();

                // Test Player class
                if (typeof Player !== 'undefined') {
                    addResult('system', 'Player Class', 'pass', 'Player class loaded successfully');
                    log('system', 'Player class: PASSED', 'success');
                } else {
                    addResult('system', 'Player Class', 'fail', 'Player class not found');
                    log('system', 'Player class: FAILED', 'error');
                }

                // Test AISystem class
                if (typeof AISystem !== 'undefined') {
                    addResult('system', 'AI System Class', 'pass', 'AISystem class loaded successfully');
                    log('system', 'AI System class: PASSED', 'success');
                } else {
                    addResult('system', 'AI System Class', 'fail', 'AISystem class not found');
                    log('system', 'AI System class: FAILED', 'error');
                }

                // Test mobile systems
                const mobileClasses = ['TouchManager', 'MobileUIManager', 'MobileGameManager'];
                mobileClasses.forEach(className => {
                    if (typeof window[className] !== 'undefined') {
                        addResult('system', className, 'pass', `${className} loaded successfully`);
                        log('system', `${className}: PASSED`, 'success');
                    } else {
                        addResult('system', className, 'fail', `${className} not found`);
                        log('system', `${className}: FAILED`, 'error');
                    }
                });

            } catch (error) {
                addResult('system', 'System Test Error', 'fail', error.message);
                log('system', `System test error: ${error.message}`, 'error');
            }
        }
        
        function testPlatformDetection() {
            log('system', 'Testing platform detection system...', 'info');
            
            try {
                // Test PlatformDetector class
                if (typeof PlatformDetector !== 'undefined') {
                    addResult('system', 'PlatformDetector Class', 'pass', 'PlatformDetector loaded successfully');
                    log('system', 'PlatformDetector class: PASSED', 'success');
                } else {
                    addResult('system', 'PlatformDetector Class', 'fail', 'PlatformDetector not found');
                    log('system', 'PlatformDetector class: FAILED', 'error');
                    return;
                }
                
                // Test platform detection
                const platformInfo = testPlatformDetector.getDebugInfo();
                log('system', `Detected platform: ${platformInfo.platform.type} (${platformInfo.platform.os})`, 'info');
                log('system', `Mobile mode: ${testPlatformDetector.shouldUseMobileMode()}`, 'info');
                log('system', `Touch device: ${platformInfo.platform.isTouchDevice}`, 'info');
                
                addResult('system', 'Platform Detection', 'pass', 
                    `Platform: ${platformInfo.platform.type}, Mobile: ${testPlatformDetector.shouldUseMobileMode()}`);
                
                // Test capability detection
                const capabilities = platformInfo.capabilities;
                const capabilityCount = Object.values(capabilities).filter(Boolean).length;
                log('system', `Detected ${capabilityCount} capabilities`, 'info');
                
                addResult('system', 'Capability Detection', 'pass', 
                    `${capabilityCount} capabilities detected (Touch: ${capabilities.touch}, WebGL: ${capabilities.webGL})`);
                
            } catch (error) {
                addResult('system', 'Platform Detection Error', 'fail', error.message);
                log('system', `Platform detection error: ${error.message}`, 'error');
            }
        }
        
        function testConditionalLoading() {
            log('system', 'Testing conditional loading system...', 'info');
            
            try {
                // Test SystemLoader class
                if (typeof SystemLoader !== 'undefined') {
                    addResult('system', 'SystemLoader Class', 'pass', 'SystemLoader loaded successfully');
                    log('system', 'SystemLoader class: PASSED', 'success');
                } else {
                    addResult('system', 'SystemLoader Class', 'fail', 'SystemLoader not found');
                    log('system', 'SystemLoader class: FAILED', 'error');
                    return;
                }
                
                // Test system loading decisions
                const systemStatus = testSystemLoader.getSystemStatus();
                log('system', `Platform: ${systemStatus.platform}`, 'info');
                log('system', `Mobile mode active: ${systemStatus.mobileModeActive}`, 'info');
                log('system', `Desktop mode active: ${systemStatus.desktopModeActive}`, 'info');
                log('system', `Tactical systems active: ${systemStatus.tacticalSystemsActive}`, 'info');
                
                // Verify correct systems are loaded/not loaded
                if (systemStatus.desktopModeActive) {
                    // In desktop mode, mobile systems should NOT be loaded
                    const mobileClasses = ['TouchManager', 'MobileGameManager'];
                    let mobileSystemsProperlySkipped = true;
                    
                    mobileClasses.forEach(className => {
                        if (typeof window[className] !== 'undefined') {
                            log('system', `WARNING: ${className} loaded in desktop mode`, 'warning');
                            mobileSystemsProperlySkipped = false;
                        }
                    });
                    
                    if (mobileSystemsProperlySkipped) {
                        addResult('system', 'Desktop Mode Loading', 'pass', 'Mobile systems properly skipped');
                        log('system', 'Desktop mode loading: PASSED - mobile systems skipped', 'success');
                    } else {
                        addResult('system', 'Desktop Mode Loading', 'warning', 'Some mobile systems loaded unnecessarily');
                        log('system', 'Desktop mode loading: WARNING - unnecessary mobile systems', 'warning');
                    }
                } else {
                    // In mobile mode, mobile systems should be loaded
                    const mobileClasses = ['TouchManager', 'MobileGameManager'];
                    let mobileSystemsLoaded = 0;
                    
                    mobileClasses.forEach(className => {
                        if (typeof window[className] !== 'undefined') {
                            mobileSystemsLoaded++;
                        }
                    });
                    
                    if (mobileSystemsLoaded === mobileClasses.length) {
                        addResult('system', 'Mobile Mode Loading', 'pass', 'All mobile systems loaded');
                        log('system', 'Mobile mode loading: PASSED - all mobile systems loaded', 'success');
                    } else {
                        addResult('system', 'Mobile Mode Loading', 'warning', `${mobileSystemsLoaded}/${mobileClasses.length} mobile systems loaded`);
                        log('system', `Mobile mode loading: WARNING - ${mobileSystemsLoaded}/${mobileClasses.length} loaded`, 'warning');
                    }
                }
                
                addResult('system', 'Conditional Loading', 'pass', 
                    `Correctly configured for ${systemStatus.platform} mode`);
                
            } catch (error) {
                addResult('system', 'Conditional Loading Error', 'fail', error.message);
                log('system', `Conditional loading error: ${error.message}`, 'error');
            }
        }

        function testAISettings() {
            log('system', 'Testing AI settings integrity...', 'info');
            
            try {
                // Create minimal AI system for testing
                const aiSystem = new AISystem();
                
                // Test AI player creation
                const testPlayer = new Player("Test AI Player", false);
                aiSystem.registerAIPlayer(testPlayer.name, 'defensive');
                
                // Check if settings exist
                const aiData = aiSystem.aiPlayers.get(testPlayer.name);
                if (aiData && aiData.settings) {
                    addResult('system', 'AI Settings Creation', 'pass', 'AI settings created successfully');
                    log('system', 'AI settings structure verified', 'success');
                    
                    // Test settings properties
                    const requiredProps = ['reactionTime', 'personality', 'difficulty'];
                    let allPropsExist = true;
                    
                    requiredProps.forEach(prop => {
                        if (!(prop in aiData.settings)) {
                            allPropsExist = false;
                            log('system', `Missing AI setting: ${prop}`, 'warning');
                        }
                    });
                    
                    if (allPropsExist) {
                        addResult('system', 'AI Settings Properties', 'pass', 'All required properties present');
                    } else {
                        addResult('system', 'AI Settings Properties', 'warning', 'Some properties missing');
                    }
                    
                } else {
                    addResult('system', 'AI Settings Creation', 'fail', 'AI settings not created or null');
                    log('system', 'AI settings creation FAILED', 'error');
                }
                
            } catch (error) {
                addResult('system', 'AI Settings Test Error', 'fail', error.message);
                log('system', `AI settings test error: ${error.message}`, 'error');
            }
        }

        function testMemoryLeaks() {
            log('system', 'Testing for memory leaks...', 'info');
            
            const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : null;
            let createdObjects = [];
            
            try {
                // Create and destroy multiple game objects
                for (let i = 0; i < 100; i++) {
                    const player = new Player(`Test Player ${i}`, false);
                    const castle = new Castle(i, i, player);
                    const army = new Army(player, []);
                    
                    createdObjects.push({ player, castle, army });
                }
                
                // Clear references
                createdObjects = [];
                
                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                }
                
                setTimeout(() => {
                    const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : null;
                    
                    if (initialMemory && finalMemory) {
                        const memoryDiff = finalMemory - initialMemory;
                        if (memoryDiff < 1024 * 1024) { // Less than 1MB difference
                            addResult('system', 'Memory Leak Test', 'pass', `Memory usage difference: ${Math.round(memoryDiff / 1024)}KB`);
                            log('system', 'No significant memory leaks detected', 'success');
                        } else {
                            addResult('system', 'Memory Leak Test', 'warning', `Potential memory leak: ${Math.round(memoryDiff / 1024)}KB`);
                            log('system', `Potential memory leak: ${Math.round(memoryDiff / 1024)}KB`, 'warning');
                        }
                    } else {
                        addResult('system', 'Memory Leak Test', 'warning', 'Memory API not available');
                        log('system', 'Memory monitoring not available in this browser', 'warning');
                    }
                }, 1000);
                
            } catch (error) {
                addResult('system', 'Memory Leak Test Error', 'fail', error.message);
                log('system', `Memory leak test error: ${error.message}`, 'error');
            }
        }

        function simulateNullSettings() {
            log('system', 'Simulating null settings bug...', 'warning');
            
            try {
                const aiSystem = new AISystem();
                const testPlayer = new Player("Bug Test Player", false);
                aiSystem.registerAIPlayer(testPlayer.name, 'aggressive');
                
                // Get AI data and intentionally corrupt settings
                const aiData = aiSystem.aiPlayers.get(testPlayer.name);
                if (aiData) {
                    log('system', `Original settings: ${JSON.stringify(aiData.settings)}`, 'info');
                    
                    // Simulate the bug by nullifying settings
                    aiData.settings = null;
                    log('system', 'Settings nullified - testing error handling...', 'warning');
                    
                    // Try to access settings (this should cause the error)
                    try {
                        const actions = [];
                        const currentTime = Date.now();
                        
                        // This is the problematic code pattern from your error
                        if (currentTime - aiData.lastAction < aiData.settings.reactionTime) {
                            log('system', 'This should not execute', 'error');
                        }
                        
                        addResult('system', 'Null Settings Bug', 'fail', 'Error not caught - bug still exists');
                        
                    } catch (settingsError) {
                        addResult('system', 'Null Settings Bug', 'fail', `Confirmed bug: ${settingsError.message}`);
                        log('system', `BUG CONFIRMED: ${settingsError.message}`, 'error');
                        
                        // Show fix suggestion
                        log('system', 'SUGGESTED FIX: Add null check before accessing settings', 'warning');
                        log('system', 'if (aiData.settings && currentTime - aiData.lastAction < aiData.settings.reactionTime)', 'info');
                    }
                } else {
                    addResult('system', 'Null Settings Setup', 'fail', 'Could not create AI data for testing');
                }
                
            } catch (error) {
                addResult('system', 'Null Settings Simulation Error', 'fail', error.message);
                log('system', `Simulation error: ${error.message}`, 'error');
            }
        }

        // Core Game Tests
        function testGameCreation() {
            log('game', 'Testing game creation...', 'info');
            
            try {
                // Create a temporary canvas for testing
                const canvas = document.createElement('canvas');
                canvas.id = 'testCanvas';
                canvas.width = 800;
                canvas.height = 600;
                document.body.appendChild(canvas);
                
                testGame = new Game('testCanvas');
                
                if (testGame) {
                    addResult('game', 'Game Creation', 'pass', 'Game instance created successfully');
                    log('game', 'Game creation: PASSED', 'success');
                    
                    // Test game properties
                    const requiredProps = ['players', 'castles', 'armies', 'systems', 'ui'];
                    let allPropsExist = true;
                    
                    requiredProps.forEach(prop => {
                        if (testGame[prop] !== undefined) {
                            log('game', `${prop}: EXISTS`, 'success');
                        } else {
                            log('game', `${prop}: MISSING`, 'warning');
                            allPropsExist = false;
                        }
                    });
                    
                    if (allPropsExist) {
                        addResult('game', 'Game Properties', 'pass', 'All game properties initialized');
                    } else {
                        addResult('game', 'Game Properties', 'warning', 'Some game properties missing');
                    }
                } else {
                    addResult('game', 'Game Creation', 'fail', 'Game instance is null');
                    log('game', 'Game creation: FAILED', 'error');
                }
                
                // Clean up
                document.body.removeChild(canvas);
                
            } catch (error) {
                addResult('game', 'Game Creation Error', 'fail', error.message);
                log('game', `Game creation error: ${error.message}`, 'error');
            }
        }

        function testPlayerSystems() {
            log('game', 'Testing player systems...', 'info');
            
            try {
                // Test human player creation
                const humanPlayer = new Player("Test Human", true);
                if (humanPlayer.isHuman === true) {
                    addResult('game', 'Human Player Creation', 'pass', 'Human player created correctly');
                    log('game', 'Human player creation: PASSED', 'success');
                } else {
                    addResult('game', 'Human Player Creation', 'fail', 'Human player flag incorrect');
                    log('game', 'Human player creation: FAILED', 'error');
                }
                
                // Test AI player creation
                const aiPlayer = new Player("Test AI", false);
                if (aiPlayer.isHuman === false) {
                    addResult('game', 'AI Player Creation', 'pass', 'AI player created correctly');
                    log('game', 'AI player creation: PASSED', 'success');
                } else {
                    addResult('game', 'AI Player Creation', 'fail', 'AI player flag incorrect');
                    log('game', 'AI player creation: FAILED', 'error');
                }
                
                // Test player resources
                if (humanPlayer.resources) {
                    addResult('game', 'Player Resources', 'pass', 'Player resources initialized');
                    log('game', `Player resources: ${JSON.stringify(humanPlayer.resources)}`, 'info');
                } else {
                    addResult('game', 'Player Resources', 'fail', 'Player resources not initialized');
                    log('game', 'Player resources: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('game', 'Player Systems Error', 'fail', error.message);
                log('game', `Player systems error: ${error.message}`, 'error');
            }
        }

        function testCastleSystems() {
            log('game', 'Testing castle systems...', 'info');
            
            try {
                const player = new Player("Castle Test Player", true);
                const castle = new Castle(5, 5, player);
                
                if (castle.owner === player) {
                    addResult('game', 'Castle Owner', 'pass', 'Castle owner set correctly');
                    log('game', 'Castle owner: PASSED', 'success');
                } else {
                    addResult('game', 'Castle Owner', 'fail', 'Castle owner incorrect');
                    log('game', 'Castle owner: FAILED', 'error');
                }
                
                // Test castle position
                if (castle.x === 5 && castle.y === 5) {
                    addResult('game', 'Castle Position', 'pass', 'Castle position set correctly');
                    log('game', 'Castle position: PASSED', 'success');
                } else {
                    addResult('game', 'Castle Position', 'fail', 'Castle position incorrect');
                    log('game', 'Castle position: FAILED', 'error');
                }
                
                // Test castle production
                if (typeof castle.goldProduction === 'number') {
                    addResult('game', 'Castle Production', 'pass', `Gold production: ${castle.goldProduction}`);
                    log('game', `Castle production: ${castle.goldProduction}`, 'success');
                } else {
                    addResult('game', 'Castle Production', 'fail', 'Castle production not set');
                    log('game', 'Castle production: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('game', 'Castle Systems Error', 'fail', error.message);
                log('game', `Castle systems error: ${error.message}`, 'error');
            }
        }

        function testCombatSystems() {
            log('game', 'Testing combat systems...', 'info');
            
            try {
                const combatSystem = new CombatSystem();
                
                if (combatSystem) {
                    addResult('game', 'Combat System Creation', 'pass', 'Combat system created successfully');
                    log('game', 'Combat system creation: PASSED', 'success');
                } else {
                    addResult('game', 'Combat System Creation', 'fail', 'Combat system is null');
                    log('game', 'Combat system creation: FAILED', 'error');
                }
                
                // Test combat calculation
                const player1 = new Player("Attacker", true);
                const player2 = new Player("Defender", false);
                const army1 = new Army(player1, []);
                const army2 = new Army(player2, []);
                
                // Add some test units
                army1.unitCount = 10;
                army2.unitCount = 8;
                
                if (typeof combatSystem.resolveCombat === 'function') {
                    addResult('game', 'Combat Resolution', 'pass', 'Combat resolution method exists');
                    log('game', 'Combat resolution method: PASSED', 'success');
                } else {
                    addResult('game', 'Combat Resolution', 'fail', 'Combat resolution method missing');
                    log('game', 'Combat resolution method: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('game', 'Combat Systems Error', 'fail', error.message);
                log('game', `Combat systems error: ${error.message}`, 'error');
            }
        }

        // AI System Stress Tests
        function stressTestAI() {
            log('ai', 'Starting AI system stress test...', 'info');
            
            try {
                const aiSystem = new AISystem();
                const startTime = Date.now();
                
                // Create multiple AI players rapidly
                for (let i = 0; i < 50; i++) {
                    const player = new Player(`Stress AI ${i}`, false);
                    aiSystem.registerAIPlayer(player.name, i % 2 === 0 ? 'aggressive' : 'defensive');
                }
                
                const creationTime = Date.now() - startTime;
                log('ai', `Created 50 AI players in ${creationTime}ms`, 'info');
                
                // Test rapid decision making
                const decisions = [];
                for (let i = 0; i < 100; i++) {
                    const decision = aiSystem.makeDecision(`Stress AI ${i % 50}`);
                    decisions.push(decision);
                }
                
                const totalTime = Date.now() - startTime;
                
                if (totalTime < 5000) { // Should complete in under 5 seconds
                    addResult('ai', 'AI Stress Test', 'pass', `Completed in ${totalTime}ms`);
                    log('ai', `Stress test completed in ${totalTime}ms`, 'success');
                } else {
                    addResult('ai', 'AI Stress Test', 'warning', `Slow performance: ${totalTime}ms`);
                    log('ai', `Stress test slow: ${totalTime}ms`, 'warning');
                }
                
            } catch (error) {
                addResult('ai', 'AI Stress Test Error', 'fail', error.message);
                log('ai', `AI stress test error: ${error.message}`, 'error');
            }
        }

        function testAIEdgeCases() {
            log('ai', 'Testing AI edge cases...', 'info');
            
            try {
                const aiSystem = new AISystem();
                
                // Test with null player name
                try {
                    aiSystem.registerAIPlayer(null, 'defensive');
                    addResult('ai', 'Null Player Name', 'fail', 'Should have thrown error');
                    log('ai', 'Null player name: FAILED - no error thrown', 'error');
                } catch (nullError) {
                    addResult('ai', 'Null Player Name', 'pass', 'Properly handled null player name');
                    log('ai', 'Null player name: PASSED - error caught', 'success');
                }
                
                // Test with invalid personality
                try {
                    aiSystem.registerAIPlayer('Invalid AI', 'invalid_personality');
                    // Check if default personality was used
                    const aiData = aiSystem.aiPlayers.get('Invalid AI');
                    if (aiData && aiData.settings && aiData.settings.personality !== 'invalid_personality') {
                        addResult('ai', 'Invalid Personality', 'pass', 'Default personality used');
                        log('ai', 'Invalid personality: PASSED - default used', 'success');
                    } else {
                        addResult('ai', 'Invalid Personality', 'warning', 'Invalid personality accepted');
                        log('ai', 'Invalid personality: WARNING - may cause issues', 'warning');
                    }
                } catch (personalityError) {
                    addResult('ai', 'Invalid Personality', 'pass', 'Error thrown for invalid personality');
                    log('ai', 'Invalid personality: PASSED - error thrown', 'success');
                }
                
                // Test making decision for non-existent player
                try {
                    const decision = aiSystem.makeDecision('NonExistentPlayer');
                    if (!decision || decision.length === 0) {
                        addResult('ai', 'Non-existent Player', 'pass', 'Empty decision for non-existent player');
                        log('ai', 'Non-existent player: PASSED', 'success');
                    } else {
                        addResult('ai', 'Non-existent Player', 'warning', 'Decision made for non-existent player');
                        log('ai', 'Non-existent player: WARNING', 'warning');
                    }
                } catch (decisionError) {
                    addResult('ai', 'Non-existent Player', 'pass', 'Error thrown for non-existent player');
                    log('ai', 'Non-existent player: PASSED - error thrown', 'success');
                }
                
            } catch (error) {
                addResult('ai', 'AI Edge Cases Error', 'fail', error.message);
                log('ai', `AI edge cases error: ${error.message}`, 'error');
            }
        }

        function corruptAISettings() {
            log('ai', 'Testing corrupted AI settings...', 'warning');
            
            try {
                const aiSystem = new AISystem();
                const player = new Player("Corruption Test", false);
                aiSystem.registerAIPlayer(player.name, 'aggressive');
                
                const aiData = aiSystem.aiPlayers.get(player.name);
                if (aiData) {
                    // Corrupt different parts of settings
                    const originalSettings = { ...aiData.settings };
                    
                    // Test 1: Corrupt reactionTime
                    aiData.settings.reactionTime = "not_a_number";
                    try {
                        const decision = aiSystem.makeDecision(player.name);
                        addResult('ai', 'Corrupted ReactionTime', 'warning', 'No error with corrupted reactionTime');
                        log('ai', 'Corrupted reactionTime: WARNING - not handled', 'warning');
                    } catch (reactionError) {
                        addResult('ai', 'Corrupted ReactionTime', 'pass', 'Error caught for corrupted reactionTime');
                        log('ai', 'Corrupted reactionTime: PASSED - error caught', 'success');
                    }
                    
                    // Restore settings
                    aiData.settings = { ...originalSettings };
                    
                    // Test 2: Corrupt personality
                    aiData.settings.personality = { not: "a_string" };
                    try {
                        const decision = aiSystem.makeDecision(player.name);
                        addResult('ai', 'Corrupted Personality', 'warning', 'No error with corrupted personality');
                        log('ai', 'Corrupted personality: WARNING - not handled', 'warning');
                    } catch (personalityError) {
                        addResult('ai', 'Corrupted Personality', 'pass', 'Error caught for corrupted personality');
                        log('ai', 'Corrupted personality: PASSED - error caught', 'success');
                    }
                }
                
            } catch (error) {
                addResult('ai', 'AI Corruption Test Error', 'fail', error.message);
                log('ai', `AI corruption test error: ${error.message}`, 'error');
            }
        }

        function nullifyAIData() {
            log('ai', 'Testing nullified AI data...', 'warning');
            
            try {
                const aiSystem = new AISystem();
                const player = new Player("Nullify Test", false);
                aiSystem.registerAIPlayer(player.name, 'defensive');
                
                // Completely nullify AI data
                aiSystem.aiPlayers.set(player.name, null);
                
                try {
                    const decision = aiSystem.makeDecision(player.name);
                    addResult('ai', 'Nullified AI Data', 'fail', 'No error with nullified AI data');
                    log('ai', 'Nullified AI data: FAILED - should throw error', 'error');
                } catch (nullError) {
                    addResult('ai', 'Nullified AI Data', 'pass', `Error caught: ${nullError.message}`);
                    log('ai', `Nullified AI data: PASSED - ${nullError.message}`, 'success');
                }
                
            } catch (error) {
                addResult('ai', 'Nullify Test Error', 'fail', error.message);
                log('ai', `Nullify test error: ${error.message}`, 'error');
            }
        }

        // Mobile/Touch System Tests
        function testTouchManager() {
            log('mobile', 'Testing touch manager...', 'info');
            
            try {
                // Create a test canvas
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 300;
                
                // Mock game object
                const mockGame = {
                    screenToGrid: (x, y) => ({ x: Math.floor(x / 32), y: Math.floor(y / 32) }),
                    getCastleAtPosition: () => null,
                    getArmyAtPosition: () => null,
                    ui: { selectedCastle: null, selectedArmy: null }
                };
                
                const touchManager = new TouchManager(canvas, mockGame);
                
                if (touchManager) {
                    addResult('mobile', 'Touch Manager Creation', 'pass', 'TouchManager created successfully');
                    log('mobile', 'TouchManager creation: PASSED', 'success');
                    
                    // Test gesture detection
                    if (touchManager.gestures) {
                        const gestureTypes = Object.keys(touchManager.gestures);
                        addResult('mobile', 'Gesture Detection', 'pass', `${gestureTypes.length} gesture types supported`);
                        log('mobile', `Gesture types: ${gestureTypes.join(', ')}`, 'info');
                    } else {
                        addResult('mobile', 'Gesture Detection', 'fail', 'Gesture system not initialized');
                        log('mobile', 'Gesture detection: FAILED', 'error');
                    }
                    
                    // Test touch state
                    if (touchManager.touchState) {
                        addResult('mobile', 'Touch State', 'pass', 'Touch state system initialized');
                        log('mobile', 'Touch state: PASSED', 'success');
                    } else {
                        addResult('mobile', 'Touch State', 'fail', 'Touch state not initialized');
                        log('mobile', 'Touch state: FAILED', 'error');
                    }
                    
                } else {
                    addResult('mobile', 'Touch Manager Creation', 'fail', 'TouchManager is null');
                    log('mobile', 'TouchManager creation: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('mobile', 'Touch Manager Error', 'fail', error.message);
                log('mobile', `TouchManager error: ${error.message}`, 'error');
            }
        }

        function testMobileUI() {
            log('mobile', 'Testing mobile UI...', 'info');
            
            try {
                // Mock dependencies
                const mockGame = { mobile: { isActive: true } };
                const mockTouchManager = { enable: () => {}, disable: () => {} };
                
                const mobileUI = new MobileUIManager(mockGame, mockTouchManager);
                
                if (mobileUI) {
                    addResult('mobile', 'Mobile UI Creation', 'pass', 'MobileUIManager created successfully');
                    log('mobile', 'MobileUIManager creation: PASSED', 'success');
                    
                    // Test responsive design
                    if (typeof mobileUI.updateLayout === 'function') {
                        addResult('mobile', 'Responsive Layout', 'pass', 'Layout update method exists');
                        log('mobile', 'Responsive layout: PASSED', 'success');
                    } else {
                        addResult('mobile', 'Responsive Layout', 'warning', 'Layout update method not found');
                        log('mobile', 'Responsive layout: WARNING', 'warning');
                    }
                    
                } else {
                    addResult('mobile', 'Mobile UI Creation', 'fail', 'MobileUIManager is null');
                    log('mobile', 'MobileUIManager creation: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('mobile', 'Mobile UI Error', 'fail', error.message);
                log('mobile', `Mobile UI error: ${error.message}`, 'error');
            }
        }

        function testPerformanceManager() {
            log('mobile', 'Testing performance manager...', 'info');
            
            try {
                const perfManager = new MobilePerformanceManager();
                
                if (perfManager) {
                    addResult('mobile', 'Performance Manager Creation', 'pass', 'Performance manager created');
                    log('mobile', 'Performance manager: PASSED', 'success');
                    
                    // Test performance monitoring
                    if (typeof perfManager.startMonitoring === 'function') {
                        perfManager.startMonitoring();
                        addResult('mobile', 'Performance Monitoring', 'pass', 'Monitoring started successfully');
                        log('mobile', 'Performance monitoring: PASSED', 'success');
                        
                        // Stop monitoring
                        if (typeof perfManager.stopMonitoring === 'function') {
                            perfManager.stopMonitoring();
                        }
                    } else {
                        addResult('mobile', 'Performance Monitoring', 'fail', 'Monitoring methods not found');
                        log('mobile', 'Performance monitoring: FAILED', 'error');
                    }
                    
                } else {
                    addResult('mobile', 'Performance Manager Creation', 'fail', 'Performance manager is null');
                    log('mobile', 'Performance manager: FAILED', 'error');
                }
                
            } catch (error) {
                addResult('mobile', 'Performance Manager Error', 'fail', error.message);
                log('mobile', `Performance manager error: ${error.message}`, 'error');
            }
        }

        function simulateLowMemory() {
            log('mobile', 'Simulating low memory conditions...', 'warning');
            
            try {
                // Create memory pressure
                const memoryConsumers = [];
                for (let i = 0; i < 100; i++) {
                    memoryConsumers.push(new Array(10000).fill(`Memory consumer ${i}`));
                }
                
                log('mobile', 'Created memory pressure', 'info');
                
                // Test if systems still function
                try {
                    const mockGame = { mobile: { isActive: true } };
                    const mobileUI = new MobileUIManager(mockGame, null);
                    
                    if (mobileUI) {
                        addResult('mobile', 'Low Memory Resilience', 'pass', 'Mobile UI still functional under memory pressure');
                        log('mobile', 'Low memory resilience: PASSED', 'success');
                    } else {
                        addResult('mobile', 'Low Memory Resilience', 'fail', 'Mobile UI failed under memory pressure');
                        log('mobile', 'Low memory resilience: FAILED', 'error');
                    }
                } catch (memoryError) {
                    addResult('mobile', 'Low Memory Resilience', 'fail', `System failed: ${memoryError.message}`);
                    log('mobile', `Low memory test failed: ${memoryError.message}`, 'error');
                }
                
                // Clean up memory consumers
                memoryConsumers.length = 0;
                
            } catch (error) {
                addResult('mobile', 'Low Memory Test Error', 'fail', error.message);
                log('mobile', `Low memory test error: ${error.message}`, 'error');
            }
        }

        // Error Simulation Tests
        function simulateRandomErrors() {
            log('error', 'Simulating random errors...', 'warning');
            
            const errorTypes = [
                () => { throw new TypeError('Simulated type error'); },
                () => { throw new ReferenceError('Simulated reference error'); },
                () => { throw new RangeError('Simulated range error'); },
                () => { throw new Error('Generic simulated error'); },
                () => { undefined.property = 'test'; },
                () => { null.method(); },
                () => { const x = {}; x.a.b.c = 'test'; }
            ];
            
            let caughtErrors = 0;
            let totalErrors = errorTypes.length;
            
            errorTypes.forEach((errorFunc, index) => {
                try {
                    errorFunc();
                } catch (error) {
                    caughtErrors++;
                    log('error', `Caught error ${index + 1}: ${error.message}`, 'info');
                }
            });
            
            if (caughtErrors === totalErrors) {
                addResult('error', 'Random Error Simulation', 'pass', `All ${totalErrors} errors caught`);
                log('error', `Random errors: PASSED - ${caughtErrors}/${totalErrors} caught`, 'success');
            } else {
                addResult('error', 'Random Error Simulation', 'warning', `${caughtErrors}/${totalErrors} errors caught`);
                log('error', `Random errors: WARNING - some errors not caught`, 'warning');
            }
        }

        function simulateMemoryError() {
            log('error', 'Simulating memory-related errors...', 'warning');
            
            try {
                // Simulate stack overflow
                function recursiveFunction(depth) {
                    if (depth > 10000) return; // Safety limit
                    return recursiveFunction(depth + 1);
                }
                
                try {
                    recursiveFunction(0);
                    addResult('error', 'Stack Overflow Test', 'warning', 'Stack overflow not triggered');
                } catch (stackError) {
                    addResult('error', 'Stack Overflow Test', 'pass', `Stack overflow caught: ${stackError.message}`);
                    log('error', `Stack overflow: PASSED - ${stackError.message}`, 'success');
                }
                
                // Simulate memory allocation error
                try {
                    const hugeArray = new Array(Number.MAX_SAFE_INTEGER);
                    addResult('error', 'Memory Allocation Test', 'warning', 'Large allocation succeeded');
                } catch (memError) {
                    addResult('error', 'Memory Allocation Test', 'pass', `Memory error caught: ${memError.message}`);
                    log('error', `Memory allocation: PASSED - ${memError.message}`, 'success');
                }
                
            } catch (error) {
                addResult('error', 'Memory Error Test', 'fail', error.message);
                log('error', `Memory error test failed: ${error.message}`, 'error');
            }
        }

        function simulateNullPointers() {
            log('error', 'Simulating null pointer errors...', 'warning');
            
            const nullPointerTests = [
                { name: 'Null Object Property', func: () => { const x = null; return x.property; } },
                { name: 'Null Object Method', func: () => { const x = null; return x.method(); } },
                { name: 'Undefined Property Chain', func: () => { const x = {}; return x.a.b.c; } },
                { name: 'Null Array Access', func: () => { const x = null; return x[0]; } },
                { name: 'Undefined Function Call', func: () => { const x = undefined; return x(); } }
            ];
            
            let caughtNullErrors = 0;
            
            nullPointerTests.forEach(test => {
                try {
                    test.func();
                    log('error', `${test.name}: No error thrown`, 'warning');
                } catch (nullError) {
                    caughtNullErrors++;
                    log('error', `${test.name}: ${nullError.message}`, 'info');
                }
            });
            
            addResult('error', 'Null Pointer Errors', 'pass', `${caughtNullErrors}/${nullPointerTests.length} null errors caught`);
            log('error', `Null pointer tests: ${caughtNullErrors}/${nullPointerTests.length} caught`, 'success');
        }

        function testErrorRecovery() {
            log('error', 'Testing error recovery mechanisms...', 'info');
            
            try {
                // Test graceful degradation
                let systemsWorking = 0;
                const totalSystems = 4;
                
                // Test Game system recovery
                try {
                    const canvas = document.createElement('canvas');
                    canvas.id = 'recoveryTestCanvas';
                    canvas.width = 400;
                    canvas.height = 300;
                    document.body.appendChild(canvas);
                    
                    const game = new Game('recoveryTestCanvas');
                    if (game) systemsWorking++;
                    
                    document.body.removeChild(canvas);
                } catch (gameError) {
                    log('error', `Game recovery failed: ${gameError.message}`, 'warning');
                }
                
                // Test Player system recovery
                try {
                    const player = new Player("Recovery Test", true);
                    if (player) systemsWorking++;
                } catch (playerError) {
                    log('error', `Player recovery failed: ${playerError.message}`, 'warning');
                }
                
                // Test AI system recovery
                try {
                    const aiSystem = new AISystem();
                    if (aiSystem) systemsWorking++;
                } catch (aiError) {
                    log('error', `AI recovery failed: ${aiError.message}`, 'warning');
                }
                
                // Test Mobile system recovery
                try {
                    const mockGame = { mobile: { isActive: true } };
                    const mobileUI = new MobileUIManager(mockGame, null);
                    if (mobileUI) systemsWorking++;
                } catch (mobileError) {
                    log('error', `Mobile recovery failed: ${mobileError.message}`, 'warning');
                }
                
                const recoveryRate = (systemsWorking / totalSystems) * 100;
                
                if (recoveryRate === 100) {
                    addResult('error', 'Error Recovery', 'pass', 'All systems recovered successfully');
                    log('error', `Error recovery: PASSED - ${recoveryRate}% systems working`, 'success');
                } else if (recoveryRate >= 75) {
                    addResult('error', 'Error Recovery', 'warning', `${recoveryRate}% systems recovered`);
                    log('error', `Error recovery: WARNING - ${recoveryRate}% systems working`, 'warning');
                } else {
                    addResult('error', 'Error Recovery', 'fail', `Only ${recoveryRate}% systems recovered`);
                    log('error', `Error recovery: FAILED - ${recoveryRate}% systems working`, 'error');
                }
                
            } catch (error) {
                addResult('error', 'Error Recovery Test', 'fail', error.message);
                log('error', `Error recovery test failed: ${error.message}`, 'error');
            }
        }

        // Monitoring Functions
        function startMonitoring() {
            log('monitor', 'Starting real-time monitoring...', 'info');
            
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
            
            monitoringInterval = setInterval(() => {
                const memory = performance.memory;
                const timestamp = new Date().toLocaleTimeString();
                
                if (memory) {
                    const memoryInfo = `Memory: ${Math.round(memory.usedJSHeapSize / 1024 / 1024)}MB used, ${Math.round(memory.totalJSHeapSize / 1024 / 1024)}MB total`;
                    log('monitor', `[${timestamp}] ${memoryInfo}`, 'info');
                } else {
                    log('monitor', `[${timestamp}] Memory monitoring not available`, 'info');
                }
                
                // Check for global errors
                if (window.onerror) {
                    log('monitor', `[${timestamp}] Error handler active`, 'info');
                }
                
                // Monitor test game if running
                if (testGame) {
                    log('monitor', `[${timestamp}] Test game running - Players: ${testGame.players ? testGame.players.length : 0}`, 'info');
                }
                
            }, 2000);
            
            log('monitor', 'Monitoring started - updates every 2 seconds', 'success');
        }

        function stopMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                log('monitor', 'Monitoring stopped', 'info');
            } else {
                log('monitor', 'No monitoring active', 'warning');
            }
        }

        function generateReport() {
            log('monitor', 'Generating test report...', 'info');
            
            let report = '=== MyHoMM Test Suite Report ===\n\n';
            report += `Generated: ${new Date().toLocaleString()}\n\n`;
            
            // Count results by category and status
            Object.keys(testResults).forEach(category => {
                const results = testResults[category];
                const passed = results.filter(r => r.status === 'pass').length;
                const failed = results.filter(r => r.status === 'fail').length;
                const warnings = results.filter(r => r.status === 'warning').length;
                
                report += `${category.toUpperCase()} TESTS:\n`;
                report += `  Passed: ${passed}\n`;
                report += `  Failed: ${failed}\n`;
                report += `  Warnings: ${warnings}\n`;
                report += `  Total: ${results.length}\n\n`;
                
                if (results.length > 0) {
                    report += '  Details:\n';
                    results.forEach(result => {
                        const status = result.status.toUpperCase().padEnd(8);
                        report += `    [${status}] ${result.name} - ${result.details}\n`;
                    });
                    report += '\n';
                }
            });
            
            // Calculate overall statistics
            const allResults = Object.values(testResults).flat();
            const totalPassed = allResults.filter(r => r.status === 'pass').length;
            const totalFailed = allResults.filter(r => r.status === 'fail').length;
            const totalWarnings = allResults.filter(r => r.status === 'warning').length;
            const successRate = allResults.length > 0 ? (totalPassed / allResults.length * 100).toFixed(1) : 0;
            
            report += `OVERALL RESULTS:\n`;
            report += `  Success Rate: ${successRate}%\n`;
            report += `  Total Passed: ${totalPassed}\n`;
            report += `  Total Failed: ${totalFailed}\n`;
            report += `  Total Warnings: ${totalWarnings}\n`;
            report += `  Total Tests: ${allResults.length}\n\n`;
            
            // Add recommendations
            report += 'RECOMMENDATIONS:\n';
            if (totalFailed > 0) {
                report += '  - Address failed tests before production deployment\n';
            }
            if (totalWarnings > 0) {
                report += '  - Review warnings for potential issues\n';
            }
            if (successRate < 90) {
                report += '  - System needs significant improvements\n';
            } else if (successRate < 95) {
                report += '  - System is good but could be improved\n';
            } else {
                report += '  - System is performing well\n';
            }
            
            // Display report
            log('monitor', report, 'info');
            
            // Also log to console for easy copying
            console.log(report);
        }

        function clearLogs() {
            ['system', 'game', 'ai', 'mobile', 'error', 'monitor'].forEach(category => {
                const output = document.getElementById(category + 'Output');
                const results = document.getElementById(category + 'Results');
                if (output) output.textContent = '';
                if (results) results.innerHTML = '';
            });
            
            testResults = {
                system: [],
                game: [],
                ai: [],
                mobile: [],
                error: []
            };
            
            log('monitor', 'All logs cleared', 'info');
        }

        // Global error handling for the test suite
        window.addEventListener('error', (event) => {
            log('error', `Global error caught: ${event.error ? event.error.message : event.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            log('error', `Unhandled promise rejection: ${event.reason}`, 'error');
        });

        // Initialize
        log('monitor', 'MyHoMM Test Suite initialized and ready', 'success');
        log('monitor', 'Click any test button to begin testing', 'info');
    </script>
</body>
</html>